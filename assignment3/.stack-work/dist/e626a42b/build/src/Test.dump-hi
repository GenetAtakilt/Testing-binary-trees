
==================== FINAL INTERFACE ====================
2019-02-13 20:18:58.8519155 UTC

interface assignment3-0.1.0.0-1DFvuy72ZJrE0fXsM2rMND:Test 8063
  interface hash: ee83a329b2e0d283c2c0877704929192
  ABI hash: 951d4113b36db65aa924975499a98e68
  export-list hash: fdd070cccca56a2b75c25ff752a263bd
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 68778ab80d079914e1f32eb3fc793056
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Test.fmap'
  Test.genTree
  Test.propFunctor
  Test.tree1
  Test.tree2
  Test.Tree{Test.Leaf Test.Node}
module dependencies:
package dependencies: QuickCheck-2.12.6.1 Win32-2.6.1.0
                      array-0.5.3.0 base-4.12.0.0* containers-0.6.0.1 deepseq-1.4.4.0
                      erf-2.0.0.0 ghc-boot-th-8.6.3 ghc-prim-0.5.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 primitive-0.6.4.0 random-1.1
                      template-haskell-2.14.0.0 tf-random-0.5 time-1.8.0.2
                      transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.12.6.1:Test.QuickCheck b66a6429c791764e3ebe5c647ad7e021
import  -/  QuickCheck-2.12.6.1:Test.QuickCheck.Arbitrary 473a3cbb3af1ca94a5aa06c407470d53
import  -/  QuickCheck-2.12.6.1:Test.QuickCheck.Gen 0ef911f7529f4738203f000e9b902ebd
import  -/  QuickCheck-2.12.6.1:Test.QuickCheck.Property 33a7006e97327b3d46bca6e7f9ac65f0
import  -/  base-4.12.0.0:Control.Monad 80b89bcb2e69935b319a1dd37eaf3802
import  -/  base-4.12.0.0:Data.Functor d76c001d92d0a1adf6f6220faa8ca3e5
import  -/  base-4.12.0.0:GHC.Base b0f6eed6c4b57b0a2f7c7570f245848b
import  -/  base-4.12.0.0:GHC.Num 6054c1c23a1433b06aa5321ae01f13b2
import  -/  base-4.12.0.0:GHC.Read 851906ff83a8b7b18e0ecaeea26c41ca
import  -/  base-4.12.0.0:GHC.Real 11a06d7fcd7db99538ab6d6f2b048af9
import  -/  base-4.12.0.0:GHC.Show 5c4c5ac15ef4d7749e0e6f06242c812a
import  -/  base-4.12.0.0:Prelude b1ccc486556b171042710ef6f2d1a539
import  -/  base-4.12.0.0:Text.ParserCombinators.ReadPrec 5508f769e0569773222f380b54078997
import  -/  base-4.12.0.0:Text.Read.Lex 96d028601ff0cabdded1fe2a85a0c70e
import  -/  ghc-prim-0.5.3:GHC.Classes 555218a5f891dab16ebc6e6e04763e77
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
68c430e6e93c167a237a9f18a1cb9489
  $fArbitraryTree ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary (Test.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),C(U))>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (Test.Tree a)
                  (Test.$fArbitraryTree1 @ a v)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R))
                  (Test.$fArbitraryTree_$cshrink @ a v) -}
68c430e6e93c167a237a9f18a1cb9489
  $fArbitraryTree1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Test.Tree a
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Test.$w$carbitrary @ a w w1 ww1 }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fArbitraryTree_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.Tree a -> [Test.Tree a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,C(U))><S,1*U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.Tree a) ->
                 case w of ww { Test.QuickCheck.Arbitrary.C:Arbitrary ww1 ww2 ->
                 Test.$w$cshrink @ a ww2 w1 }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (Test.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Test.Tree a)
                  (Test.$fEqTree_$c== @ a v)
                  (Test.$fEqTree_$c/= @ a v) -}
68c430e6e93c167a237a9f18a1cb9489
  $fEqTree_$c/= ::
    GHC.Classes.Eq a => Test.Tree a -> Test.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Test.Tree a)
                   (y :: Test.Tree a) ->
                 case Test.$fEqTree_$c== @ a $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fEqTree_$c== ::
    GHC.Classes.Eq a => Test.Tree a -> Test.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
8e632d2fba70400682a7077f4b376dbc
  $fEqTree_$s$c== ::
    Test.Tree GHC.Types.Int
    -> Test.Tree GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fFunctorTree :: GHC.Base.Functor Test.Tree
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Test.Tree Test.$fFunctorTree_$cfmap Test.$fFunctorTree_$c<$ -}
68c430e6e93c167a237a9f18a1cb9489
  $fFunctorTree_$c<$ :: a -> Test.Tree b -> Test.Tree a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fFunctorTree_$cfmap :: (a -> b) -> Test.Tree a -> Test.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree :: GHC.Classes.Ord a => GHC.Classes.Ord (Test.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Test.Tree a)
                  (Test.$fOrdTree_$cp1Ord @ a v)
                  (Test.$fOrdTree_$ccompare @ a v)
                  (Test.$fOrdTree_$c< @ a v)
                  (Test.$fOrdTree_$c<= @ a v)
                  (\ (a1 :: Test.Tree a) (b :: Test.Tree a) ->
                   Test.$fOrdTree_$c< @ a v b a1)
                  (Test.$fOrdTree_$c>= @ a v)
                  (Test.$fOrdTree_$cmax @ a v)
                  (Test.$fOrdTree_$cmin @ a v) -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$c< ::
    GHC.Classes.Ord a => Test.Tree a -> Test.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$c<= ::
    GHC.Classes.Ord a => Test.Tree a -> Test.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Test.Tree a)
                   (b :: Test.Tree a) ->
                 case Test.$fOrdTree_$c< @ a $dOrd b a1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$c>= ::
    GHC.Classes.Ord a => Test.Tree a -> Test.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Test.Tree a)
                   (b :: Test.Tree a) ->
                 case Test.$fOrdTree_$c< @ a $dOrd a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$ccompare ::
    GHC.Classes.Ord a =>
    Test.Tree a -> Test.Tree a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$cmax ::
    GHC.Classes.Ord a => Test.Tree a -> Test.Tree a -> Test.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Test.Tree a)
                   (y :: Test.Tree a) ->
                 case Test.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$cmin ::
    GHC.Classes.Ord a => Test.Tree a -> Test.Tree a -> Test.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Test.Tree a)
                   (y :: Test.Tree a) ->
                 case Test.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
68c430e6e93c167a237a9f18a1cb9489
  $fOrdTree_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Test.Tree a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Test.$fEqTree @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
68c430e6e93c167a237a9f18a1cb9489
  $fReadTree :: GHC.Read.Read a => GHC.Read.Read (Test.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Read.Read a).
                  @ (Test.Tree a)
                  (Test.$fReadTree_$creadsPrec @ a v)
                  (Test.$fReadTree_$creadList @ a v)
                  (Test.$fReadTree1 @ a v)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Test.Tree
                                     a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Test.Tree a>_R))
                  (Test.$fReadTree_$creadListPrec @ a v) -}
68c430e6e93c167a237a9f18a1cb9489
  $fReadTree1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Test.Tree a -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A)><L,U><L,U> -}
68c430e6e93c167a237a9f18a1cb9489
  $fReadTree_$creadList ::
    GHC.Read.Read a => Text.ParserCombinators.ReadP.ReadS [Test.Tree a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Test.Tree a]
                   (((GHC.Read.list
                        @ (Test.Tree a)
                        (Test.$fReadTree1 @ a $dRead)
                          `cast`
                        ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <Test.Tree
                                           a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Test.Tree a>_R)))
                       `cast`
                     (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Test.Tree a]>_R)
                       GHC.Read.$fRead()8)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <[Test.Tree a]>_R)
                      @ [Test.Tree a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Test.Tree a]))) -}
68c430e6e93c167a237a9f18a1cb9489
  $fReadTree_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec [Test.Tree a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 GHC.Read.list
                   @ (Test.Tree a)
                   (Test.$fReadTree1 @ a $dRead)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Test.Tree
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Test.Tree a>_R))) -}
68c430e6e93c167a237a9f18a1cb9489
  $fReadTree_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (Test.Tree a)
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Test.Tree a)
                   (Test.$fReadTree1
                      @ a
                      $dRead
                      n
                      @ (Test.Tree a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Test.Tree a)))) -}
68c430e6e93c167a237a9f18a1cb9489
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Test.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Test.Tree a)
                  (Test.$fShowTree_$cshowsPrec @ a v)
                  (Test.$fShowTree_$cshow @ a v)
                  (Test.$fShowTree_$cshowList @ a v) -}
bc589f688de2f08a41fd744adc43e812
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
68c430e6e93c167a237a9f18a1cb9489
  $fShowTree_$cshow ::
    GHC.Show.Show a => Test.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Test.Tree a) ->
                 Test.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   Test.$fShowTree1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68c430e6e93c167a237a9f18a1cb9489
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Test.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Test.Tree a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Test.Tree a)
                   (Test.$fShowTree_$cshowsPrec @ a $dShow Test.$fShowTree1)
                   ls
                   s) -}
68c430e6e93c167a237a9f18a1cb9489
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Test.Tree a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Test.Tree a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Test.$w$cshowsPrec @ a w ww1 w2 }) -}
cf31cabbb028a952acb5715b5563d4cb
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7258985466945529093##
                   14565772641743234472##
                   Test.$trModule
                   Test.$tc'Leaf2
                   1#
                   Test.$tc'Leaf1) -}
912c89a943288ac375fd10b3166ca6d2
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
856b6503d3c44c3046275c2383e72fe6
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.$tc'Leaf3) -}
0107bc7dde704a18e5b0ca6ff9d15948
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
64c21ba19d0298b5d3d9027b909a8694
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18002303523310519020##
                   4129891403464697113##
                   Test.$trModule
                   Test.$tc'Node2
                   1#
                   Test.$tc'Node1) -}
45f07141de640a540477fa01e63ec282
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8ee183ddc94ee69497a34a75738f7ba8
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.$tc'Node3) -}
45903bc2711a9bd73a4973f67e53f0b4
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
c4fcfbc3dd6f9cb3f2c6155f2f4d41ba
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8727992657836524630##
                   2070490966746767537##
                   Test.$trModule
                   Test.$tcTree1
                   0#
                   GHC.Types.krep$*Arr*) -}
749fe0782428f0e769a6e5fd3f7bd288
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.$tcTree2) -}
c989951e76ed289aded55fa6cf1d616d
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
97ae99d7995f3c9b40664d01da5a3bf4
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Test.$trModule3 Test.$trModule1) -}
d1ff1e61d670a2cdd5091034f3bfa617
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.$trModule2) -}
ac2d0cbe8a0bcf7a84a6cf94f50685d7
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Test"#) -}
13598f65178233d78dae910e2869f64c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.$trModule4) -}
c51966d0776de80ffb25204a491121e9
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("assignment3-0.1.0.0-1DFvuy72ZJrE0fXsM2rMND"#) -}
68c430e6e93c167a237a9f18a1cb9489
  $w$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Prim.Int# -> Test.Tree a
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><S,U>, Inline: [2],
     Unfolding: (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (ww :: GHC.Prim.Int#) ->
                 let {
                   lvl4 :: Test.QuickCheck.Random.QCGen
                           -> GHC.Types.Int -> Test.Tree a
                     {- Arity: 2, Strictness: <L,U><L,U>,
                        Unfolding: InlineRule (2, True, False)
                                   (\ (r :: Test.QuickCheck.Random.QCGen) (n :: GHC.Types.Int) ->
                                    Test.Leaf
                                      @ a
                                      ((Test.QuickCheck.Arbitrary.arbitrary @ a w)
                                         `cast`
                                       (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                                         r
                                         n)) -}
                   = \ (r :: Test.QuickCheck.Random.QCGen) (n :: GHC.Types.Int) ->
                     Test.Leaf
                       @ a
                       ((Test.QuickCheck.Arbitrary.arbitrary @ a w)
                          `cast`
                        (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                          r
                          n)
                 } in
                 letrec {
                   $wgo :: GHC.Prim.Int# -> Test.QuickCheck.Gen.Gen (Test.Tree a)
                     {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                   = \ (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.<=# ww1 1# of lwild {
                       DEFAULT
                       -> let {
                            sub :: Test.QuickCheck.Gen.Gen (Test.Tree a)
                            = $wgo (GHC.Prim.uncheckedIShiftRA# ww1 1#)
                          } in
                          Test.QuickCheck.Gen.oneof
                            @ (Test.Tree a)
                            (GHC.Types.:
                               @ (Test.QuickCheck.Gen.Gen (Test.Tree a))
                               lvl4 `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R))
                               (GHC.Types.:
                                  @ (Test.QuickCheck.Gen.Gen (Test.Tree a))
                                  (\ (w2 :: Test.QuickCheck.Random.QCGen) (w3 :: GHC.Types.Int) ->
                                   case w2
                                          `cast`
                                        (Test.QuickCheck.Random.N:QCGen[0]) of ww2 { System.Random.TF.Gen.TFGen ww3 ww4 ww5 ww6 ww7 ww8 ->
                                   case System.Random.TF.Gen.$wtfGenSplit
                                          ww3
                                          ww4
                                          ww5
                                          ww6 of ww9 { (#,#) ww10 ww11 ->
                                   case ww11 of ww12 { System.Random.TF.Gen.TFGen ww13 ww14 ww15 ww16 ww17 ww18 ->
                                   case System.Random.TF.Gen.$wtfGenSplit
                                          ww13
                                          ww14
                                          ww15
                                          ww16 of ww19 { (#,#) ww20 ww21 ->
                                   Test.Node
                                     @ a
                                     (sub `cast` (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R)
                                        ww10 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                                        w3)
                                     (sub `cast` (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R)
                                        ww20 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                                        w3) } } } })
                                    `cast`
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R))
                                  (GHC.Types.[] @ (Test.QuickCheck.Gen.Gen (Test.Tree a)))))
                       1#
                       -> lvl4
                            `cast`
                          (Sym (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R)) }
                 } in
                 ($wgo ww) `cast` (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R)
                   w1
                   (GHC.Types.I# ww)) -}
68c430e6e93c167a237a9f18a1cb9489
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> Test.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2] -}
68c430e6e93c167a237a9f18a1cb9489
  $w$cshrink :: (a -> [a]) -> Test.Tree a -> [Test.Tree a]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><S,1*U>,
     Inline: [2] -}
19dd19b9132d33eff8575e9ba1e0b73c
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> Test.Tree GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [2] -}
8a3e4e3f36b07fe341b71edffd4e89c9
  $wgenTree ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.Tree a
  {- Arity: 7,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [2] -}
68c430e6e93c167a237a9f18a1cb9489
  data Tree a = Leaf a | Node (Test.Tree a) (Test.Tree a)
974af5c0aa74fa77a26aa2f2e1d10c9d
  fmap' :: (a -> b) -> Test.Tree a -> Test.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a @ b (f2 :: a -> b) (ds :: Test.Tree a) ->
                 case ds of wild {
                   Test.Leaf x -> Test.Leaf @ b (f2 x)
                   Test.Node l r
                   -> Test.Node
                        @ b
                        (Test.$fFunctorTree_$cfmap @ a @ b f2 r)
                        (Test.$fFunctorTree_$cfmap @ a @ b f2 l) }) -}
e46e9717a71a1b307383a4a065c282c0
  genTree ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    GHC.Types.Int -> Test.QuickCheck.Gen.Gen (Test.Tree a)
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A)><S(S),1*U(1*U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Test.genTree1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0] <Test.Tree a>_R)) -}
91ac7a2d4e1298bdc47cddcf4cd399f6
  genTree1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    GHC.Types.Int
    -> Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Test.Tree a
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A)><S(S),1*U(1*U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww2 { System.Random.TF.Gen.TFGen ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Test.$wgenTree @ a w ww1 ww3 ww4 ww5 ww6 w3 } }) -}
bf254a32f13b509bd3b517afdefb4a31
  propFunctor ::
    ((GHC.Types.Int -> GHC.Types.Int)
     -> Test.Tree GHC.Types.Int -> Test.Tree GHC.Types.Int)
    -> Test.Tree GHC.Types.Int -> Test.QuickCheck.Property.Property
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><L,U>,
     Unfolding: (\ (f2 :: (GHC.Types.Int -> GHC.Types.Int)
                          -> Test.Tree GHC.Types.Int -> Test.Tree GHC.Types.Int)
                   (trr :: Test.Tree GHC.Types.Int) ->
                 let {
                   x :: Test.Tree GHC.Types.Int = f2 (GHC.Base.id @ GHC.Types.Int) trr
                 } in
                 let {
                   res :: GHC.Types.Bool = Test.$fEqTree_$s$c== x trr
                 } in
                 Test.QuickCheck.Property.counterexample_$scounterexample
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (Test.$w$s$cshowsPrec 0# x (GHC.Types.[] @ GHC.Types.Char))
                      (case res of wild {
                         GHC.Types.False
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              Test.QuickCheck.Property.=/=1
                              (Test.$w$s$cshowsPrec 0# trr (GHC.Types.[] @ GHC.Types.Char))
                         GHC.Types.True
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              Test.QuickCheck.Property.=/=3
                              (Test.$w$s$cshowsPrec 0# trr (GHC.Types.[] @ GHC.Types.Char)) }))
                   res) -}
26ee250e63103bbced64d724491767b0
  tree1 :: Test.Tree GHC.Types.Int
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Test.Leaf @ GHC.Types.Int Test.$fShowTree1) -}
264fdd237e65f25fd5c78cc17a0cbdc5
  tree2 :: Test.Tree GHC.Types.Int
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Test.Node @ GHC.Types.Int Test.tree6 Test.tree4) -}
e755444650366384aadf2b198783cd90
  tree4 :: Test.Tree GHC.Types.Int
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Test.Leaf @ GHC.Types.Int Test.tree5) -}
591733f5f46237dd6796b1394616d423
  tree5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
aeebad22f5de58688068f5d5c22a9546
  tree6 :: Test.Tree GHC.Types.Int
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Test.Leaf @ GHC.Types.Int Test.tree7) -}
90694916e9a6cab0a09a327686b3d5f6
  tree7 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Test.Tree]
  = Test.$fArbitraryTree
instance [safe] GHC.Classes.Eq [Test.Tree] = Test.$fEqTree
instance [safe] GHC.Base.Functor [Test.Tree] = Test.$fFunctorTree
instance [safe] GHC.Classes.Ord [Test.Tree] = Test.$fOrdTree
instance [safe] GHC.Read.Read [Test.Tree] = Test.$fReadTree
instance [safe] GHC.Show.Show [Test.Tree] = Test.$fShowTree
"SPEC $c== @ Int" forall ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  Test.$fEqTree_$c== @ GHC.Types.Int $dEq = Test.$fEqTree_$s$c==
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

